{"0": {"alertID": "0", "alertName": "Directory Browsing", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "548", "alertWASCID": "48", "alertTechTargeted": "All", "alertSummary": "It is possible to view the directory listing.  Directory listing may reveal hidden scripts, include files, backup source files, etc. which can be accessed to read sensitive information.", "alertSolution": "Disable directory browsing.  If this is required, make sure the listed files does not induce risks.", "alertOtherInfo": "N/A", "alertReferences": ["https://httpd.apache.org/docs/mod/core.html#options"]}, "1": {"alertID": "2", "alertName": "Private IP Disclosure", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "A private IP (such as 10.x.x.x, 172.x.x.x, 192.168.x.x) or an Amazon EC2 private hostname (for example, ip-10-0-56-78) has been found in the HTTP response body. This information might be helpful for further attacks targeting internal systems.", "alertSolution": "Remove the private IP address from the HTTP response body.  For comments, use JSP/ASP/PHP comment instead of HTML/JavaScript comment which can be seen by client browsers.", "alertOtherInfo": "192.168.36.127", "alertReferences": ["https://tools.ietf.org/html/rfc1918"]}, "2": {"alertID": "3", "alertName": "Session ID in URL Rewrite", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "3": {"alertID": "3-1", "alertName": "Session ID in URL Rewrite", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "URL rewrite is used to track user session ID. The session ID may be disclosed via cross-site referer header. In addition, the session ID might be stored in browser history or server logs.", "alertSolution": "For secure content, put session ID in a cookie. To be even more secure consider using a combination of cookie and URL rewrite.", "alertOtherInfo": "N/A", "alertReferences": ["https://seclists.org/webappsec/2002/q4/111"]}, "4": {"alertID": "3-2", "alertName": "Session ID in URL Rewrite", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "URL rewrite is used to track user session ID. The session ID may be disclosed via cross-site referer header. In addition, the session ID might be stored in browser history or server logs.", "alertSolution": "For secure content, put session ID in a cookie. To be even more secure consider using a combination of cookie and URL rewrite.", "alertOtherInfo": "N/A", "alertReferences": ["https://seclists.org/webappsec/2002/q4/111"]}, "5": {"alertID": "3-3", "alertName": "Referer Exposes Session ID", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "A hyperlink pointing to another host name was found. As session ID URL rewrite is used, it may be disclosed in referer header to external hosts.", "alertSolution": "This is a risk if the session ID is sensitive and the hyperlink refers to an external or third party host. For secure content, put session ID in secured session cookie.", "alertOtherInfo": "N/A", "alertReferences": ["https://seclists.org/webappsec/2002/q4/111"]}, "6": {"alertID": "6", "alertName": "Path Traversal", "alertType": "Active", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "7": {"alertID": "6-1", "alertName": "Path Traversal", "alertType": "Active", "alertRisk": "High", "alertCWEID": "22", "alertWASCID": "33", "alertTechTargeted": "All", "alertSummary": "The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.", "alertSolution": "Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  For filenames, use stringent allow lists that limit the character set to be used. If feasible, only allow a single \".\" character in the filename to avoid weaknesses, and exclude directory separators such as \"/\". Use an allow list of allowable file extensions.  Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into \"cleaning\" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. \"sensi.tiveFile\") and the sanitizing mechanism removes the character resulting in the valid filename, \"sensitiveFile\". If the input data are now assumed to be safe, then the file may be compromised.   Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked.  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes \"..\" sequences and symbolic links.  Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.  When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  Run your code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by your software.  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows you to specify restrictions on file operations.  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/Path_Traversal", "https://cwe.mitre.org/data/definitions/22.html"]}, "8": {"alertID": "6-2", "alertName": "Path Traversal", "alertType": "Active", "alertRisk": "High", "alertCWEID": "22", "alertWASCID": "33", "alertTechTargeted": "All", "alertSummary": "The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.", "alertSolution": "Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  For filenames, use stringent allow lists that limit the character set to be used. If feasible, only allow a single \".\" character in the filename to avoid weaknesses, and exclude directory separators such as \"/\". Use an allow list of allowable file extensions.  Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into \"cleaning\" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. \"sensi.tiveFile\") and the sanitizing mechanism removes the character resulting in the valid filename, \"sensitiveFile\". If the input data are now assumed to be safe, then the file may be compromised.   Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked.  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes \"..\" sequences and symbolic links.  Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.  When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  Run your code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by your software.  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows you to specify restrictions on file operations.  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/Path_Traversal", "https://cwe.mitre.org/data/definitions/22.html"]}, "9": {"alertID": "6-3", "alertName": "Path Traversal", "alertType": "Active", "alertRisk": "High", "alertCWEID": "22", "alertWASCID": "33", "alertTechTargeted": "All", "alertSummary": "The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.", "alertSolution": "Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  For filenames, use stringent allow lists that limit the character set to be used. If feasible, only allow a single \".\" character in the filename to avoid weaknesses, and exclude directory separators such as \"/\". Use an allow list of allowable file extensions.  Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into \"cleaning\" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. \"sensi.tiveFile\") and the sanitizing mechanism removes the character resulting in the valid filename, \"sensitiveFile\". If the input data are now assumed to be safe, then the file may be compromised.   Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked.  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes \"..\" sequences and symbolic links.  Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.  When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  Run your code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by your software.  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows you to specify restrictions on file operations.  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/Path_Traversal", "https://cwe.mitre.org/data/definitions/22.html"]}, "10": {"alertID": "6-4", "alertName": "Path Traversal", "alertType": "Active", "alertRisk": "High", "alertCWEID": "22", "alertWASCID": "33", "alertTechTargeted": "All", "alertSummary": "The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.", "alertSolution": "Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  For filenames, use stringent allow lists that limit the character set to be used. If feasible, only allow a single \".\" character in the filename to avoid weaknesses, and exclude directory separators such as \"/\". Use an allow list of allowable file extensions.  Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into \"cleaning\" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. \"sensi.tiveFile\") and the sanitizing mechanism removes the character resulting in the valid filename, \"sensitiveFile\". If the input data are now assumed to be safe, then the file may be compromised.   Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked.  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes \"..\" sequences and symbolic links.  Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.  When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  Run your code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by your software.  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows you to specify restrictions on file operations.  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/Path_Traversal", "https://cwe.mitre.org/data/definitions/22.html"]}, "11": {"alertID": "6-5", "alertName": "Path Traversal", "alertType": "Active", "alertRisk": "High", "alertCWEID": "22", "alertWASCID": "33", "alertTechTargeted": "All", "alertSummary": "The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.", "alertSolution": "Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  For filenames, use stringent allow lists that limit the character set to be used. If feasible, only allow a single \".\" character in the filename to avoid weaknesses, and exclude directory separators such as \"/\". Use an allow list of allowable file extensions.  Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into \"cleaning\" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. \"sensi.tiveFile\") and the sanitizing mechanism removes the character resulting in the valid filename, \"sensitiveFile\". If the input data are now assumed to be safe, then the file may be compromised.   Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked.  Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes \"..\" sequences and symbolic links.  Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.  When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  Run your code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by your software.  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows you to specify restrictions on file operations.  This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/Path_Traversal", "https://cwe.mitre.org/data/definitions/22.html"]}, "12": {"alertID": "7", "alertName": "Remote File Inclusion", "alertType": "Active", "alertRisk": "High", "alertCWEID": "98", "alertWASCID": "5", "alertTechTargeted": "All", "alertSummary": "Remote File Include (RFI) is an attack technique used to exploit \u201cdynamic file include\u201d mechanisms in web applications. When web applications take user input (URL, parameter value, etc.) and pass them into file include commands, the web application might be tricked into including remote files with malicious code.", "alertSolution": "Phase: Architecture and Design When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to \"inbox.txt\" and ID 2 could map to \"profile.txt\". Features such as the ESAPI AccessReferenceMap provide this capability.  Phases: Architecture and Design; Operation Run your code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by your software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows you to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails. For PHP, the interpreter offers restrictions such as open basedir or safe mode which can make it more difficult for an attacker to escape out of the application. Also consider Suhosin, a hardened PHP extension, which includes various options that disable some of the more dangerous PHP features.  Phase: Implementation Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\" For filenames, use stringent allow lists that limit the character set to be used. If feasible, only allow a single \".\" character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as \"/\" to avoid CWE-36. Use an allow list of allowable file extensions, which will help to avoid CWE-434.  Phases: Architecture and Design; Operation Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce your attack surface.  Phases: Architecture and Design; Implementation Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Many file inclusion problems occur because the programmer assumed that certain inputs could not be modified, especially for cookies and URL components.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.2-Testing_for_Remote_File_Inclusion", "https://cwe.mitre.org/data/definitions/98.html"]}, "13": {"alertID": "10003", "alertName": "Vulnerable JS Library", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "829", "alertWASCID": "Technologies Targeted", "alertTechTargeted": "Tags", "alertSummary": "The identified library ExampleLibrary, version x.y.z is vulnerable.", "alertSolution": "Please upgrade to the latest version of ExampleLibrary.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "14": {"alertID": "10010", "alertName": "Cookie No HttpOnly Flag", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "1004", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "A cookie has been set without the HttpOnly flag, which means that the cookie can be accessed by JavaScript. If a malicious script can be run on this page then the cookie will be accessible and can be transmitted to another site. If this is a session cookie then session hijacking may be possible.", "alertSolution": "Ensure that the HttpOnly flag is set for all cookies.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/HttpOnly"]}, "15": {"alertID": "10011", "alertName": "Cookie Without Secure Flag", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "614", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "A cookie has been set without the secure flag, which means that the cookie can be accessed via unencrypted connections.", "alertSolution": "Whenever a cookie contains sensitive information or is a session token, then it should always be passed using an encrypted channel. Ensure that the secure flag is set for cookies containing such sensitive information.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/02-Testing_for_Cookies_Attributes.html"]}, "16": {"alertID": "10015", "alertName": "Re-examine Cache-control Directives", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "525", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The cache-control header has not been set properly or is missing, allowing the browser and proxies to cache content. For static assets like css, js, or image files this might be intended, however, the resources should be reviewed to ensure that no sensitive content will be cached.", "alertSolution": "For secure content, ensure the cache-control HTTP header is set with \"no-cache, no-store, must-revalidate\". If an asset should be cached consider setting the directives \"public, max-age, immutable\".", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#web-content-caching", "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control", "https://grayduck.mn/2021/09/13/cache-control-recommendations/"]}, "17": {"alertID": "10017", "alertName": "Cross-Domain JavaScript Source File Inclusion", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "829", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "The page includes one or more script files from a third-party domain.", "alertSolution": "Ensure JavaScript source files are loaded from only trusted sources, and the sources can't be controlled by end users of the application.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "18": {"alertID": "10019", "alertName": "Content-Type Header Missing", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "19": {"alertID": "10019-1", "alertName": "Content-Type Header Missing", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "345", "alertWASCID": "12", "alertTechTargeted": "All", "alertSummary": "The Content-Type header was either missing or empty.", "alertSolution": "Ensure each page is setting the specific and appropriate content-type value for the content being delivered.", "alertOtherInfo": "N/A", "alertReferences": ["https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/gg622941(v=vs.85)"]}, "20": {"alertID": "10019-2", "alertName": "Content-Type Header Empty", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "345", "alertWASCID": "12", "alertTechTargeted": "All", "alertSummary": "The Content-Type header was either missing or empty.", "alertSolution": "Ensure each page is setting the specific and appropriate content-type value for the content being delivered.", "alertOtherInfo": "N/A", "alertReferences": ["https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/gg622941(v=vs.85)"]}, "21": {"alertID": "10020", "alertName": "Anti-clickjacking Header", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "22": {"alertID": "10020-1", "alertName": "Missing Anti-clickjacking Header", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "1021", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "The response does not include either Content-Security-Policy with \u2018frame-ancestors\u2019 directive or X-Frame-Options to protect against \u2018ClickJacking\u2019 attacks.", "alertSolution": "Modern Web browsers support the Content-Security-Policy and X-Frame-Options HTTP headers. Ensure one of them is set on all web pages returned by your site/app. If you expect the page to be framed only by pages on your server (e.g. it's part of a FRAMESET) then you'll want to use SAMEORIGIN, otherwise if you never expect the page to be framed, you should use DENY. Alternatively consider implementing Content Security Policy's \"frame-ancestors\" directive.", "alertOtherInfo": "N/A", "alertReferences": ["https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options"]}, "23": {"alertID": "10020-2", "alertName": "Multiple X-Frame-Options Header Entries", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "1021", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "X-Frame-Options (XFO) headers were found, a response with multiple XFO header entries may not be predictably treated by all user-agents.", "alertSolution": "Ensure only a single X-Frame-Options header is present in the response.", "alertOtherInfo": "N/A", "alertReferences": ["https://tools.ietf.org/html/rfc7034"]}, "24": {"alertID": "10020-3", "alertName": "X-Frame-Options Defined via META (Non-compliant with Spec)", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "1021", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "An X-Frame-Options (XFO) META tag was found, defining XFO via a META tag is explicitly not supported by the spec (RFC 7034).", "alertSolution": "Ensure X-Frame-Options is set via a response header field.  Alternatively consider implementing Content Security Policy's \"frame-ancestors\" directive.", "alertOtherInfo": "N/A", "alertReferences": ["https://tools.ietf.org/html/rfc7034#section-4"]}, "25": {"alertID": "10020-4", "alertName": "X-Frame-Options Setting Malformed", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "1021", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "An X-Frame-Options header was present in the response but the value was not correctly set.", "alertSolution": "Ensure a valid setting is used on all web pages returned by your site (if you expect the page to be framed only by pages on your server (e.g. it's part of a FRAMESET) then you'll want to use SAMEORIGIN, otherwise if you never expect the page to be framed, you should use DENY.  Alternatively consider implementing Content Security Policy's \"frame-ancestors\" directive.", "alertOtherInfo": "N/A", "alertReferences": ["https://tools.ietf.org/html/rfc7034#section-2.1"]}, "26": {"alertID": "10021", "alertName": "X-Content-Type-Options Header Missing", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "The Anti-MIME-Sniffing header X-Content-Type-Options was not set to \u2019nosniff\u2019. This allows older versions of Internet Explorer and Chrome to perform MIME-sniffing on the response body, potentially causing the response body to be interpreted and displayed as a content type other than the declared content type. Current (early 2014) and legacy versions of Firefox will use the declared content type (if one is set), rather than performing MIME-sniffing.", "alertSolution": "Ensure that the application/web server sets the Content-Type header appropriately, and that it sets the X-Content-Type-Options header to 'nosniff' for all web pages. If possible, ensure that the end user uses a standards-compliant and modern web browser that does not perform MIME-sniffing at all, or that can be directed by the web application/web server to not perform MIME-sniffing.", "alertOtherInfo": "This issue still applies to error type pages (401, 403, 500, etc.) as those pages are often still affected by injection issues, in which case there is still concern for browsers sniffing pages away from their actual content type. At \"High\" threshold this scan rule will not alert on client or server error responses.", "alertReferences": ["https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/gg622941(v=vs.85)", "https://owasp.org/www-community/Security_Headers"]}, "27": {"alertID": "10023", "alertName": "Information Disclosure - Debug Error Messages", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The response appeared to contain common error messages returned by platforms such as ASP.NET, and Web-servers such as IIS and Apache. You can configure the list of common debug messages.", "alertSolution": "Disable debugging messages before pushing to production.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "28": {"alertID": "10024", "alertName": "Information Disclosure - Sensitive Information in URL", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The request appeared to contain sensitive information leaked in the URL. This can violate PCI and most organizational compliance policies. You can configure the list of strings for this check to add or remove values specific to your environment.", "alertSolution": "Do not pass sensitive information in URIs.", "alertOtherInfo": "The URL appears to contain US Social Security Number(s)", "alertReferences": "N/A"}, "29": {"alertID": "10025", "alertName": "Information Disclosure - Sensitive Information in HTTP Referrer Header", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The HTTP header may have leaked a potentially sensitive parameter to another domain. This can violate PCI and most organizational compliance policies. You can configure the list of strings for this check to add or remove values specific to your environment.", "alertSolution": "Do not pass sensitive information in URIs.", "alertOtherInfo": "The URL in the HTTP referrer header field appears to contain US Social Security Number(s).", "alertReferences": "N/A"}, "30": {"alertID": "10027", "alertName": "Information Disclosure - Suspicious Comments", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.", "alertSolution": "Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.", "alertOtherInfo": "The following pattern was used: \\bFIXME\\b and was detected in the element starting with: \"<!-- FixMe: cookie: root=true; Secure -->\", see evidence field for the suspicious comment/snippet.", "alertReferences": "N/A"}, "31": {"alertID": "10028", "alertName": "Open Redirect", "alertType": "Passive", "alertRisk": "High", "alertCWEID": "601", "alertWASCID": "38", "alertTechTargeted": "All", "alertSummary": "Open redirects are one of the OWASP 2010 Top Ten vulnerabilities. This check looks at user-supplied input in query string parameters and POST data to identify where open redirects might be possible. Open redirects occur when an application allows user-supplied input (e.g. http://nottrusted.com) to control an offsite redirect. This is generally a pretty accurate way to find where 301 or 302 redirects could be exploited by spammers or phishing attacks.", "alertSolution": "To avoid the open redirect vulnerability, parameters of the application script/program must be validated before sending 302 HTTP code (redirect) to the client browser. Implement safe redirect functionality that only redirects to relative URI's, or a list of trusted domains", "alertOtherInfo": "The 301 or 302 response to a request for the following URL appeared to contain user input in the location header:  https://example.com/transact  The user input found was:  place=evil.com  The context was:  http://evil.com", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html", "https://cwe.mitre.org/data/definitions/601.html"]}, "32": {"alertID": "10029", "alertName": "Cookie Poisoning", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "565", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "This check looks at user-supplied input in query string parameters and POST data to identify where cookie parameters might be controlled. This is called a cookie poisoning attack, and becomes exploitable when an attacker can manipulate the cookie in various ways. In some cases this will not be exploitable, however, allowing URL parameters to set cookie values is generally considered a bug.", "alertSolution": "Do not allow user input to control cookie names and values. If some query string parameters must be set in cookie values, be sure to filter out semicolon's that can serve as name/value pair delimiters.", "alertOtherInfo": "An attacker may be able to poison cookie values through URL parameters.  Try injecting a semicolon to see if you can add cookie values (e.g. name=controlledValue;name=anotherValue;).  This was identified at:  https://example.com/transact  User-input was found in the following cookie: value=poison; SameSite=Strict  The user input was: place=poison", "alertReferences": ["https://en.wikipedia.org/wiki/HTTP_cookie", "https://cwe.mitre.org/data/definitions/565.html"]}, "33": {"alertID": "10030", "alertName": "User Controllable Charset", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "20", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "This check looks at user-supplied input in query string parameters and POST data to identify where Content-Type or meta tag charset declarations might be user-controlled. Such charset declarations should always be declared by the application. If an attacker can control the response charset, they could manipulate the HTML to perform XSS or other attacks. For example, an attacker controlling the  element charset value is able to declare UTF-7 and is also able to include enough user-controlled payload early in the HTML document to have it interpreted as UTF-7. By encoding their payload with UTF-7 the attacker is able to bypass any server-side XSS protections and embed script in the page.", "alertSolution": "Force UTF-8 in all charset declarations. If user-input is required to decide a charset declaration, ensure that only an allowed list is used.", "alertOtherInfo": "A(n) [Content-Type HTTP header] tag [charset] attribute  The user input found was: cs=utf-8  The charset value it controlled was: utf-8", "alertReferences": "N/A"}, "34": {"alertID": "10031", "alertName": "User Controllable HTML Element Attribute (Potential XSS)", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "20", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "This check looks at user-supplied input in query string parameters and POST data to identify where certain HTML attribute values might be controlled. This provides hot-spot detection for XSS (cross-site scripting) that will require further review by a security analyst to determine exploitability.", "alertSolution": "Validate all input and sanitize output it before writing to any HTML attributes.", "alertOtherInfo": "User-controlled HTML attribute values were found. Try injecting special characters to see if XSS might be possible. The page at the following URL:  http://example.com/i.php?name=fred  appears to include user input in:   a(n) [img] tag [alt] attribute   The user input found was: name=fred  The user-controlled value was: pscanrules.usercontrolledhtmlattributes.", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html"]}, "35": {"alertID": "10032", "alertName": "Viewstate", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "36": {"alertID": "10032-1", "alertName": "Potential IP Addresses Found in the Viewstate", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "642", "alertWASCID": "14", "alertTechTargeted": "All", "alertSummary": "The following potential IP addresses were found being serialized in the viewstate field:", "alertSolution": "Verify the provided information isn't confidential.", "alertOtherInfo": "[]", "alertReferences": "N/A"}, "37": {"alertID": "10032-2", "alertName": "Emails Found in the Viewstate", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "642", "alertWASCID": "14", "alertTechTargeted": "All", "alertSummary": "The following emails were found being serialized in the viewstate field:", "alertSolution": "Verify the provided information isn't confidential.", "alertOtherInfo": "[]", "alertReferences": "N/A"}, "38": {"alertID": "10032-3", "alertName": "Old Asp.Net Version in Use", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "642", "alertWASCID": "14", "alertTechTargeted": "All", "alertSummary": "This website uses ASP.NET version 1.0 or 1.1.", "alertSolution": "Ensure the engaged framework is still supported by Microsoft.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "39": {"alertID": "10032-4", "alertName": "Viewstate without MAC Signature (Unsure)", "alertType": "Passive", "alertRisk": "High", "alertCWEID": "642", "alertWASCID": "14", "alertTechTargeted": "All", "alertSummary": "This website uses ASP.NET\u2019s Viewstate but maybe without any MAC.", "alertSolution": "Ensure the MAC is set for all pages on this website.", "alertOtherInfo": "N/A", "alertReferences": ["http://msdn.microsoft.com/en-us/library/ff649308.aspx"]}, "40": {"alertID": "10032-5", "alertName": "Viewstate without MAC Signature (Sure)", "alertType": "Passive", "alertRisk": "High", "alertCWEID": "642", "alertWASCID": "14", "alertTechTargeted": "All", "alertSummary": "This website uses ASP.NET\u2019s Viewstate but without any MAC.", "alertSolution": "Ensure the MAC is set for all pages on this website.", "alertOtherInfo": "N/A", "alertReferences": ["http://msdn.microsoft.com/en-us/library/ff649308.aspx"]}, "41": {"alertID": "10032-6", "alertName": "Split Viewstate in Use", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "642", "alertWASCID": "14", "alertTechTargeted": "All", "alertSummary": "This website uses ASP.NET\u2019s Viewstate and its value is split into several chunks.", "alertSolution": "None - the guys running the server may have tuned the configuration as this isn't the default setting.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "42": {"alertID": "10033", "alertName": "Directory Browsing", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "548", "alertWASCID": "16", "alertTechTargeted": "All", "alertSummary": "It is possible to view a listing of the directory contents. Directory listings may reveal hidden scripts, include files, backup source files, etc., which can be accessed to reveal sensitive information.", "alertSolution": "Configure the web server to disable directory browsing.", "alertOtherInfo": "Web server identified: Apache 2", "alertReferences": ["https://cwe.mitre.org/data/definitions/548.html"]}, "43": {"alertID": "10034", "alertName": "Heartbleed OpenSSL Vulnerability (Indicative)", "alertType": "Passive", "alertRisk": "High", "alertCWEID": "119", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "The TLS and DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, potentially disclosing sensitive information.", "alertSolution": "Update to OpenSSL 1.0.1g or later. Re-issue HTTPS certificates. Change asymmetric private keys and shared secret keys, since these may have been compromised, with no evidence of compromise in the server log files.", "alertOtherInfo": "OpenSSL/1.0.1e is in use. Note however that the reported version could contain back-ported security fixes, and so the issue could be a false positive. This is common on Red Hat, for instance.", "alertReferences": ["https://nvd.nist.gov/vuln/detail/CVE-2014-0160"]}, "44": {"alertID": "10035", "alertName": "Strict-Transport-Security Header", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "45": {"alertID": "10035-1", "alertName": "Strict-Transport-Security Header Not Set", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "HTTP Strict Transport Security (HSTS) is a web security policy mechanism whereby a web server declares that complying user agents (such as a web browser) are to interact with it using only secure HTTPS connections (i.e. HTTP layered over TLS/SSL). HSTS is an IETF standards track protocol and is specified in RFC 6797.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is configured to enforce Strict-Transport-Security.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html", "https://owasp.org/www-community/Security_Headers", "https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security", "https://caniuse.com/stricttransportsecurity", "https://datatracker.ietf.org/doc/html/rfc6797"]}, "46": {"alertID": "10035-2", "alertName": "Strict-Transport-Security Disabled", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "A HTTP Strict Transport Security (HSTS) header was found, but it contains the directive max-age=0 which disables the control and instructs browsers to reset any previous HSTS related settings. See RFC 6797 for further details.\nHTTP Strict Transport Security (HSTS) is a web security policy mechanism whereby a web server declares that complying user agents (such as a web browser) are to interact with it using only secure HTTPS connections (i.e. HTTP layered over TLS/SSL).", "alertSolution": "Review the configuration of this control. Ensure that your web server, application server, load balancer, etc. is configured to set Strict-Transport-Security with an appropriate max-age value.", "alertOtherInfo": "N/A", "alertReferences": ["https://datatracker.ietf.org/doc/html/rfc6797#section-6.2"]}, "47": {"alertID": "10035-3", "alertName": "Strict-Transport-Security Multiple Header Entries (Non-compliant with Spec)", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "HTTP Strict Transport Security (HSTS) headers were found, a response with multiple HSTS header entries is not compliant with the specification (RFC 6797) and only the first HSTS header will be processed others will be ignored by user agents or the HSTS policy may be incorrectly applied.\nHTTP Strict Transport Security (HSTS) is a web security policy mechanism whereby a web server declares that complying user agents (such as a web browser) are to interact with it using only secure HTTPS connections (i.e. HTTP layered over TLS/SSL).", "alertSolution": "Ensure that only one component in your stack: code, web server, application server, load balancer, etc. is configured to set or add a HTTP Strict-Transport-Security (HSTS) header.", "alertOtherInfo": "N/A", "alertReferences": ["https://datatracker.ietf.org/doc/html/rfc6797#section-8.1"]}, "48": {"alertID": "10035-4", "alertName": "Strict-Transport-Security Header on Plain HTTP Response", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "A HTTP Strict Transport Security (HSTS) header was found, but HSTS headers are ignored on plain (non-HTTPS) responses.\nHTTP Strict Transport Security (HSTS) is a web security policy mechanism whereby a web server declares that complying user agents (such as a web browser) are to interact with it using only secure HTTPS connections (i.e. HTTP layered over TLS/SSL).", "alertSolution": "Review the configuration of this control. Ensure that your web server, application server, load balancer, etc. is configured to set Strict-Transport-Security for HTTPS responses.", "alertOtherInfo": "N/A", "alertReferences": ["https://datatracker.ietf.org/doc/html/rfc6797#section-8.1"]}, "49": {"alertID": "10035-5", "alertName": "Strict-Transport-Security Missing Max-Age (Non-compliant with Spec)", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "A HTTP Strict Transport Security (HSTS) header was found, but it is missing the max-age directive (or the directive is missing a value). See RFC 6797 for further details.\nHTTP Strict Transport Security (HSTS) is a web security policy mechanism whereby a web server declares that complying user agents (such as a web browser) are to interact with it using only secure HTTPS connections (i.e. HTTP layered over TLS/SSL).", "alertSolution": "Review the configuration of this control. Ensure that your web server, application server, load balancer, etc. is configured to set Strict-Transport-Security with an appropriate max-age value.", "alertOtherInfo": "N/A", "alertReferences": ["https://datatracker.ietf.org/doc/html/rfc6797#section-6.2"]}, "50": {"alertID": "10035-6", "alertName": "Strict-Transport-Security Defined via META (Non-compliant with Spec)", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "A HTTP Strict Transport Security (HSTS) META tag was found, defining HTTP Strict Transport Security (HSTS) via a META tag is explicitly not supported by the spec (RFC 6797).", "alertSolution": "Do not attempt to set HTTP Strict Transport Security (HSTS) via a META tag.", "alertOtherInfo": "N/A", "alertReferences": ["https://datatracker.ietf.org/doc/html/rfc6797#section-8.5"]}, "51": {"alertID": "10035-7", "alertName": "Strict-Transport-Security Max-Age Malformed (Non-compliant with Spec)", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "A HTTP Strict Transport Security (HSTS) header was found, but it contains quotes preceding the max-age directive (the max-age value can be quoted, but the directive itself cannot be). See RFC 6797 for further details.\nHTTP Strict Transport Security (HSTS) is a web security policy mechanism whereby a web server declares that complying user agents (such as a web browser) are to interact with it using only secure HTTPS connections (i.e. HTTP layered over TLS/SSL).", "alertSolution": "Review the configuration of this control. Ensure that your web server, application server, load balancer, etc. is configured to set Strict-Transport-Security with an appropriate format.", "alertOtherInfo": "N/A", "alertReferences": ["https://datatracker.ietf.org/doc/html/rfc6797#section-6.1"]}, "52": {"alertID": "10035-8", "alertName": "Strict-Transport-Security Malformed Content (Non-compliant with Spec)", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "A HTTP Strict Transport Security (HSTS) header was found, but it contains some content that was not expected (perhaps curly quotes), the expectation is that the content be printable ASCII characters.", "alertSolution": "Review the configuration of this control. Ensure that your web server, application server, load balancer, etc. is configured to set Strict-Transport-Security with appropriate content.", "alertOtherInfo": "N/A", "alertReferences": ["https://datatracker.ietf.org/doc/html/rfc6797"]}, "53": {"alertID": "10036", "alertName": "HTTP Server Response Header", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "54": {"alertID": "10036-1", "alertName": "Server Leaks its Webserver Application via \"Server\" HTTP Response Header Field", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The web/application server is leaking the application it uses as a webserver via the \u201cServer\u201d HTTP response header. Access to such information may facilitate attackers identifying other vulnerabilities your web/application server is subject to. This information alone, i.e. without a version string, is not very dangerous for the security of a server, nevertheless this information in the response header field is almost always useless and thus just an obsolete attacking vector.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is configured to suppress the \"Server\" header or provide generic details.", "alertOtherInfo": "N/A", "alertReferences": ["https://httpd.apache.org/docs/current/mod/core.html#servertokens", "https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff648552(v=pandp.10)", "https://www.troyhunt.com/shhh-dont-let-your-response-headers/"]}, "55": {"alertID": "10036-2", "alertName": "Server Leaks Version Information via \"Server\" HTTP Response Header Field", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The web/application server is leaking version information via the \u201cServer\u201d HTTP response header. Access to such information may facilitate attackers identifying other vulnerabilities your web/application server is subject to.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is configured to suppress the \"Server\" header or provide generic details.", "alertOtherInfo": "N/A", "alertReferences": ["https://httpd.apache.org/docs/current/mod/core.html#servertokens", "https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff648552(v=pandp.10)", "https://www.troyhunt.com/shhh-dont-let-your-response-headers/"]}, "56": {"alertID": "10037", "alertName": "Server Leaks Information via \"X-Powered-By\" HTTP Response Header Field(s)", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The web/application server is leaking information via one or more \u201cX-Powered-By\u201d HTTP response headers. Access to such information may facilitate attackers identifying other frameworks/components your web application is reliant upon and the vulnerabilities such components may be subject to.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is configured to suppress \"X-Powered-By\" headers.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/01-Information_Gathering/08-Fingerprint_Web_Application_Framework", "https://www.troyhunt.com/2012/02/shhh-dont-let-your-response-headers.html"]}, "57": {"alertID": "10038", "alertName": "Content Security Policy (CSP) Header Not Set", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "58": {"alertID": "10038-1", "alertName": "Content Security Policy (CSP) Header Not Set", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is configured to set the Content-Security-Policy header.", "alertOtherInfo": "N/A", "alertReferences": ["https://developer.mozilla.org/en-US/docs/Web/Security/CSP/Introducing_Content_Security_Policy", "https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html", "https://www.w3.org/TR/CSP/", "https://w3c.github.io/webappsec-csp/", "https://web.dev/articles/csp", "https://caniuse.com/#feat=contentsecuritypolicy", "https://content-security-policy.com/"]}, "59": {"alertID": "10038-2", "alertName": "Obsolete Content Security Policy (CSP) Header Found", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "The \u201cX-Content-Security-Policy\u201d and \u201cX-WebKit-CSP\u201d headers are no longer recommended.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is configured to set the Content-Security-Policy header.", "alertOtherInfo": "N/A", "alertReferences": ["https://developer.mozilla.org/en-US/docs/Web/Security/CSP/Introducing_Content_Security_Policy", "https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html", "https://www.w3.org/TR/CSP/", "https://w3c.github.io/webappsec-csp/", "https://web.dev/articles/csp", "https://caniuse.com/#feat=contentsecuritypolicy", "https://content-security-policy.com/"]}, "60": {"alertID": "10038-3", "alertName": "Content Security Policy (CSP) Report-Only Header Found", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "The response contained a Content-Security-Policy-Report-Only header, this may indicate a work-in-progress implementation, or an oversight in promoting pre-Prod to Prod, etc.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is configured to set the Content-Security-Policy header.", "alertOtherInfo": "N/A", "alertReferences": ["https://www.w3.org/TR/CSP2/", "https://w3c.github.io/webappsec-csp/", "https://caniuse.com/#feat=contentsecuritypolicy", "https://content-security-policy.com/"]}, "61": {"alertID": "10039", "alertName": "X-Backend-Server Header Information Leak", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The server is leaking information pertaining to backend systems (such as hostnames or IP addresses). Armed with this information an attacker may be able to attack other systems or more directly/efficiently attack those systems.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is configured to suppress X-Backend-Server headers.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "62": {"alertID": "10040", "alertName": "Secure Pages Include Mixed Content", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "311", "alertWASCID": "4", "alertTechTargeted": "All", "alertSummary": "The page includes mixed content, that is content accessed via HTTP instead of HTTPS.", "alertSolution": "A page that is available over SSL/TLS must be comprised completely of content which is transmitted over SSL/TLS. The page must not contain any content that is transmitted over unencrypted HTTP.  This includes content from third party sites.", "alertOtherInfo": "tag=img src=http://example.com/file", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html"]}, "63": {"alertID": "10041", "alertName": "HTTP to HTTPS Insecure Transition in Form Post", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "This check looks for insecure HTTP pages that host HTTPS forms. The issue is that an insecure HTTP page can easily be hijacked through MITM and the secure HTTPS form can be replaced or spoofed.", "alertSolution": "Use HTTPS for landing pages that host secure forms.", "alertOtherInfo": "The response to the following request over HTTP included an HTTPS form tag action attribute value:  http://example.com The context was:  <form name=\"someform\" action=\"https://example.com/processform\">", "alertReferences": "N/A"}, "64": {"alertID": "10042", "alertName": "HTTPS to HTTP Insecure Transition in Form Post", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "319", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "This check identifies secure HTTPS pages that host insecure HTTP forms. The issue is that a secure page is transitioning to an insecure page when data is uploaded through a form. The user may think they\u2019re submitting data to a secure page when in fact they are not.", "alertSolution": "Ensure sensitive data is only sent over secured HTTPS channels.", "alertOtherInfo": "The response to the following request over HTTPS included an HTTP form tag action attribute value:  https://example.com The context was:  <form name=\"someform\" action=\"http://example.com/processform\">", "alertReferences": "N/A"}, "65": {"alertID": "10043", "alertName": "User Controllable JavaScript Event (XSS)", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "20", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "This check looks at user-supplied input in query string parameters and POST data to identify where certain HTML attribute values might be controlled. This provides hot-spot detection for XSS (cross-site scripting) that will require further review by a security analyst to determine exploitability.", "alertSolution": "Validate all input and sanitize output it before writing to any Javascript on* events.", "alertOtherInfo": "User-controlled javascript event(s) was found. Exploitability will need to be manually determined. The page at the following URL:  http://example.com/i.php?place=moon&name=Foo  includes the following Javascript event which may be attacker-controllable:   User-input was found in the following data of an [onerror] event: foo  The user input was: foo", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html"]}, "66": {"alertID": "10044", "alertName": "Big Redirect Detected (Potential Sensitive Information Leak)", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "67": {"alertID": "10044-1", "alertName": "Big Redirect Detected (Potential Sensitive Information Leak)", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "201", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The server has responded with a redirect that seems to provide a large response. This may indicate that although the server sent a redirect it also responded with body content (which may include sensitive details, PII, etc.).", "alertSolution": "Ensure that no sensitive information is leaked via redirect responses. Redirect responses should have almost no content.", "alertOtherInfo": "Location header URI length: 18 [http://example.com]. Predicted response size: 318. Response Body Length: 319.", "alertReferences": "N/A"}, "68": {"alertID": "10044-2", "alertName": "Multiple HREFs Redirect Detected (Potential Sensitive Information Leak)", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "201", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The server has responded with a redirect that seems to contain multiple links. This may indicate that although the server sent a redirect it also responded with body content links (which may include sensitive details, PII, lead to admin panels, etc.).", "alertSolution": "Ensure that no sensitive information is leaked via redirect responses. Redirect responses should have almost no content.", "alertOtherInfo": "The response contained 3 occurrences of \"HREF\".", "alertReferences": "N/A"}, "69": {"alertID": "10045", "alertName": "Source Code Disclosure - /WEB-INF Folder", "alertType": "Active", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "70": {"alertID": "10045-1", "alertName": "Source Code Disclosure - /WEB-INF Folder", "alertType": "Active", "alertRisk": "High", "alertCWEID": "541", "alertWASCID": "34", "alertTechTargeted": "All", "alertSummary": "Java source code was disclosed by the web server in Java class files in the WEB-INF folder. The class files can be dis-assembled to produce source code which very closely matches the original source code.", "alertSolution": "The web server should be configured to not serve the /WEB-INF folder or its contents to web browsers, since it contains sensitive information such as compiled Java source code and properties files which may contain credentials. Java classes deployed with the application should be obfuscated, as an additional layer of defence in a \"defence-in-depth\" approach.", "alertOtherInfo": "class A { }", "alertReferences": ["https://owasp.org/www-community/attacks/Forced_browsing", "https://cwe.mitre.org/data/definitions/425.html"]}, "71": {"alertID": "10045-2", "alertName": "Properties File Disclosure - /WEB-INF folder", "alertType": "Active", "alertRisk": "High", "alertCWEID": "541", "alertWASCID": "34", "alertTechTargeted": "All", "alertSummary": "A Java class in the /WEB-INF folder disclosed the presence of the properties file. Properties file are not intended to be publicly accessible, and typically contain configuration information, application credentials, or cryptographic keys.", "alertSolution": "The web server should be configured to not serve the /WEB-INF folder or its contents to web browsers.  It may also be possible to remove the /WEB-INF folder.", "alertOtherInfo": "The reference to the properties file was found in the dis-assembled Java source code for Java class [https://example.com/foo.class].", "alertReferences": ["https://owasp.org/www-community/attacks/Forced_browsing", "https://cwe.mitre.org/data/definitions/425.html"]}, "72": {"alertID": "10050", "alertName": "Retrieved from Cache", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "Technologies Targeted", "alertWASCID": "Tags"}, "73": {"alertID": "10052", "alertName": "X-ChromeLogger-Data (XCOLD) Header Information Leak", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The server is leaking information through the X-ChromeLogger-Data (or X-ChromePhp-Data) response header. The content of such headers can be customized by the developer, however it is not uncommon to find: server file system locations, vhost declarations, etc.", "alertSolution": "Disable this functionality in Production when it might leak information that could be leveraged by an attacker. Alternatively ensure that use of the functionality is tied to a strong authorization check and only available to administrators or support personnel for troubleshooting purposes not general users.", "alertOtherInfo": "The following represents an attempt to base64 decode the value: {\"version\":\"4.0\",\"columns\":[\"label\",\"log\",\"backtrace\",\"type\"],\"rows\":[[\"request\",\"Matched route \\\"app_security_login\\\" (parameters: \\\"_controller\\\": \\\"BackEnd\\\\AppBundle\\\\Controller\\\\SecurityController::loginAction\\\", \\\"_route\\\": \\\"app_security_login\\\")\",\"unknown\",\"info\"],[\"security\",\"Populated SecurityContext with an anonymous Token\",\"unknown\",\"info\"]],\"request_uri\":\"\\/login\"}", "alertReferences": ["https://craig.is/writing/chrome-logger"]}, "74": {"alertID": "10054", "alertName": "Cookie without SameSite Attribute", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "75": {"alertID": "10054-1", "alertName": "Cookie without SameSite Attribute", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "1275", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "A cookie has been set without the SameSite attribute, which means that the cookie can be sent as a result of a \u2018cross-site\u2019 request. The SameSite attribute is an effective counter measure to cross-site request forgery, cross-site script inclusion, and timing attacks.", "alertSolution": "Ensure that the SameSite attribute is set to either 'lax' or ideally 'strict' for all cookies.", "alertOtherInfo": "N/A", "alertReferences": ["https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site"]}, "76": {"alertID": "10054-2", "alertName": "Cookie with SameSite Attribute None", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "1275", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "A cookie has been set with its SameSite attribute set to \u201cnone\u201d, which means that the cookie can be sent as a result of a \u2018cross-site\u2019 request. The SameSite attribute is an effective counter measure to cross-site request forgery, cross-site script inclusion, and timing attacks.", "alertSolution": "Ensure that the SameSite attribute is set to either 'lax' or ideally 'strict' for all cookies.", "alertOtherInfo": "N/A", "alertReferences": ["https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site"]}, "77": {"alertID": "10054-3", "alertName": "Cookie with Invalid SameSite Attribute", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "1275", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "A cookie has been set with an invalid SameSite attribute value, which means that the cookie can be sent as a result of a \u2018cross-site\u2019 request. The SameSite attribute is an effective counter measure to cross-site request forgery, cross-site script inclusion, and timing attacks.", "alertSolution": "Ensure that the SameSite attribute is set to either 'lax' or ideally 'strict' for all cookies.", "alertOtherInfo": "N/A", "alertReferences": ["https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site"]}, "78": {"alertID": "10055", "alertName": "CSP", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "79": {"alertID": "10055-1", "alertName": "CSP: X-Content-Security-Policy", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "The header X-Content-Security-Policy was found on this response. While it is a good sign that CSP is implemented to some degree the policy specified in this header has not been analyzed by ZAP. To ensure full support by modern browsers ensure that the Content-Security-Policy header is defined and attached to responses.", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "80": {"alertID": "10055-2", "alertName": "CSP: X-WebKit-CSP", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "The header X-WebKit-CSP was found on this response. While it is a good sign that CSP is implemented to some degree the policy specified in this header has not been analyzed by ZAP. To ensure full support by modern browsers ensure that the Content-Security-Policy header is defined and attached to responses.", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "81": {"alertID": "10055-3", "alertName": "CSP: Notices", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "Warnings:\\nThis host name is unusual, and likely meant to be a keyword that is missing the required quotes: 'none'.", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "82": {"alertID": "10055-4", "alertName": "CSP: Wildcard Directive", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "The following directives either allow wildcard sources (or ancestors), are not defined, or are overly broadly defined:  connect-src", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "83": {"alertID": "10055-5", "alertName": "CSP: script-src unsafe-inline", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "script-src includes unsafe-inline.", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "84": {"alertID": "10055-6", "alertName": "CSP: style-src unsafe-inline", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "style-src includes unsafe-inline.", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "85": {"alertID": "10055-7", "alertName": "CSP: script-src unsafe-hashes", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "script-src includes unsafe-hashes, an attacker will be able to use any of the code covered by such hashes.", "alertReferences": ["https://www.w3.org/TR/CSP3/#unsafe-hashes-usage", "https://content-security-policy.com/examples/allow-inline-script/"]}, "86": {"alertID": "10055-8", "alertName": "CSP: style-src unsafe-hashes", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "style-src includes unsafe-hashes, an attacker will be able to use any of the code covered by such hashes.", "alertReferences": ["https://www.w3.org/TR/CSP3/#unsafe-hashes-usage", "https://content-security-policy.com/examples/allow-inline-style/"]}, "87": {"alertID": "10055-9", "alertName": "CSP: Malformed Policy (Non-ASCII)", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "A non-ASCII character was encountered while attempting to parse the policy, thus rendering it invalid (no further evaluation occurred). The following invalid characters were collected: \u2018\u2019", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "88": {"alertID": "10055-10", "alertName": "CSP: script-src unsafe-eval", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks. Including (but not limited to) Cross Site Scripting (XSS), and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "script-src includes unsafe-eval.", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "89": {"alertID": "10055-11", "alertName": "CSP: Meta Policy Invalid Directive", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "The policy specified via meta element contains either or both the sandbox or frame-ancestors directive, which are not permitted inside meta CSP definitions.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "N/A", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "90": {"alertID": "10055-12", "alertName": "CSP: Header & Meta", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "693", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "The message contained both CSP specified via header and via Meta tag. It was not possible to union these policies in order to perform an analysis. Therefore, they have been evaluated individually.", "alertSolution": "Ensure that your web server, application server, load balancer, etc. is properly configured to set the Content-Security-Policy header.", "alertOtherInfo": "N/A", "alertReferences": ["https://www.w3.org/TR/CSP/", "https://caniuse.com/#search=content+security+policy", "https://content-security-policy.com/", "https://github.com/HtmlUnit/htmlunit-csp", "https://developers.google.com/web/fundamentals/security/csp#policy_applies_to_a_wide_variety_of_resources"]}, "91": {"alertID": "10056", "alertName": "X-Debug-Token Information Leak", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The response contained an X-Debug-Token or X-Debug-Token-Link header. This indicates that Symfony\u2019s Profiler may be in use and exposing sensitive data.", "alertSolution": "Limit access to Symfony's Profiler, either via authentication/authorization or limiting inclusion of the header to specific clients (by IP, etc.).", "alertOtherInfo": "By accessing a URL in the form http://target_host/_profiler/token_value (i.e.: http://example.com/_profiler_/123ab4), you may gain access to the profiler and further leaked information.", "alertReferences": ["https://symfony.com/doc/current/cookbook/profiler/profiling_data.html", "https://symfony.com/blog/new-in-symfony-2-4-quicker-access-to-the-profiler-when-working-on-an-api"]}, "92": {"alertID": "10057", "alertName": "Username Hash Found", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "284", "alertWASCID": "2", "alertTechTargeted": "All", "alertSummary": "A hash of a username (admin) was found in the response. This may indicate that the application is subject to an Insecure Direct Object Reference (IDOR) vulnerability. Manual testing will be required to see if this discovery can be abused.", "alertSolution": "Use per user or session indirect object references (create a temporary mapping at time of use). Or, ensure that each use of a direct object reference is tied to an authorization check to ensure the user is authorized for the requested object.", "alertOtherInfo": "The hash was an SHA1, with value: d033e22ae348aeb5660fc2140aec35850c4da997", "alertReferences": ["https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References.html"]}, "93": {"alertID": "10058", "alertName": "GET for POST", "alertType": "Active", "alertRisk": "Informational", "alertCWEID": "16", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "A request that was originally observed as a POST was also accepted as a GET. This issue does not represent a security weakness unto itself, however, it may facilitate simplification of other attacks. For example if the original POST is subject to Cross-Site Scripting (XSS), then this finding may indicate that a simplified (GET based) XSS may also be possible.", "alertSolution": "Ensure that only POST is accepted where POST is expected.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "94": {"alertID": "10061", "alertName": "X-AspNet-Version Response Header", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "933", "alertWASCID": "14", "alertTechTargeted": "All", "alertSummary": "Server leaks information via \u201cX-AspNet-Version\u201d/\u201cX-AspNetMvc-Version\u201d HTTP response header field(s).", "alertSolution": "Configure the server so it will not return those headers.", "alertOtherInfo": "An attacker can use this information to exploit known vulnerabilities.", "alertReferences": ["https://www.troyhunt.com/shhh-dont-let-your-response-headers/", "https://blogs.msdn.microsoft.com/varunm/2013/04/23/remove-unwanted-http-response-headers/"]}, "95": {"alertID": "10062", "alertName": "PII Disclosure", "alertType": "Passive", "alertRisk": "High", "alertCWEID": "359", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The response contains Personally Identifiable Information, such as CC number, SSN and similar sensitive data.", "alertSolution": "Check the response for the potential presence of personally identifiable information (PII), ensure nothing sensitive is leaked by the application.", "alertOtherInfo": "Credit Card Type detected: Visa Bank Identification Number: 471618 Brand: VISA Category: PURCHASING Issuer: U.S. BANK N.A. ND", "alertReferences": "N/A"}, "96": {"alertID": "10096", "alertName": "Timestamp Disclosure", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "A timestamp was disclosed by the application/web server", "alertSolution": "Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.", "alertOtherInfo": "N/A", "alertReferences": ["http://projects.webappsec.org/w/page/13246936/Information%20Leakage"]}, "97": {"alertID": "10097", "alertName": "Hash Disclosure", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "Technologies Targeted", "alertWASCID": "Tags", "alertTechTargeted": "OWASP_2021_A04", "alertSummary": "A hash was disclosed by the web server.", "alertSolution": "Ensure that hashes that are used to protect credentials or other resources are not leaked by the web server or database. There is typically no requirement for password hashes to be accessible to the web browser.", "alertOtherInfo": "N/A", "alertReferences": ["http://projects.webappsec.org/w/page/13246936/Information%20Leakage", "http://openwall.info/wiki/john/sample-hashes"]}, "98": {"alertID": "10098", "alertName": "Cross-Domain Misconfiguration", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "264", "alertWASCID": "14", "alertTechTargeted": "All", "alertSummary": "Web browser data loading may be possible, due to a Cross Origin Resource Sharing (CORS) misconfiguration on the web server", "alertSolution": "Ensure that sensitive data is not available in an unauthenticated manner (using IP address white-listing, for instance). Configure the \"Access-Control-Allow-Origin\" HTTP header to a more restrictive set of domains, or remove all CORS headers entirely, to allow the web browser to enforce the Same Origin Policy (SOP) in a more restrictive manner.", "alertOtherInfo": "N/A", "alertReferences": ["https://vulncat.fortify.com/en/detail?id=desc.config.dotnet.html5_overly_permissive_cors_policy"]}, "99": {"alertID": "10104", "alertName": "User Agent Fuzzer", "alertType": "Active", "alertRisk": "Informational", "alertCWEID": "WASC", "alertWASCID": "All", "alertTechTargeted": "CUSTOM_PAYLOADS", "alertSummary": "Check for differences in response based on fuzzed User Agent (eg. mobile sites, access as a Search Engine Crawler). Compares the response statuscode and the hashcode of the response body with the original response.", "alertSolution": "Solution", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/wstg"]}, "100": {"alertID": "10105", "alertName": "Weak Authentication Method", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "WASC", "alertWASCID": "Technologies Targeted", "alertTechTargeted": "Tags", "alertSummary": "HTTP basic or digest authentication has been used over an unsecured connection. The credentials can be read and then reused by someone with access to the network.", "alertSolution": "Protect the connection using HTTPS or use a stronger authentication mechanism", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html"]}, "101": {"alertID": "10108", "alertName": "Reverse Tabnabbing", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "Technologies Targeted", "alertWASCID": "Tags", "alertTechTargeted": "OWASP_2021_A04", "alertSummary": "At least one link on this page is vulnerable to Reverse tabnabbing as it uses a target attribute without using both of the \u201cnoopener\u201d and \u201cnoreferrer\u201d keywords in the \u201crel\u201d attribute, which allows the target page to take control of this page.", "alertSolution": "Do not use a target attribute, or if you have to then also add the attribute: rel=\"noopener noreferrer\".", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/Reverse_Tabnabbing", "https://dev.to/ben/the-targetblank-vulnerability-by-example", "https://mathiasbynens.github.io/rel-noopener/", "https://medium.com/@jitbit/target-blank-the-most-underestimated-vulnerability-ever-96e328301f4c"]}, "102": {"alertID": "10109", "alertName": "Modern Web Application", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "Technologies Targeted", "alertWASCID": "Tags"}, "103": {"alertID": "10202", "alertName": "Absence of Anti-CSRF Tokens", "alertType": "Passive", "alertRisk": "N/A", "alertCWEID": "WASC", "alertWASCID": "Technologies Targeted", "alertTechTargeted": "Tags", "alertSummary": "A cross-site request forgery is an attack that involves forcing a victim to send an HTTP request to a target destination without their knowledge or intent in order to perform an action as the victim. The underlying cause is application functionality using predictable URL/form actions in a repeatable way. The nature of the attack is that CSRF exploits the trust that a web site has for a user. By contrast, cross-site scripting (XSS) exploits the trust that a user has for a web site. Like XSS, CSRF attacks are not necessarily cross-site, but they can be. Cross-site request forgery is also known as CSRF, XSRF, one-click attack, session riding, confused deputy, and sea surf.", "alertSolution": "Phase: Architecture and Design Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, use anti-CSRF packages such as the OWASP CSRFGuard.  Phase: Implementation Ensure that your application is free of cross-site scripting issues, because most CSRF defenses can be bypassed using attacker-controlled script.  Phase: Architecture and Design Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330). Note that this can be bypassed using XSS.  Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation. Note that this can be bypassed using XSS.  Use the ESAPI Session Management control. This control includes a component for CSRF.  Do not use the GET method for any request that triggers a state change.  Phase: Implementation Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html", "https://cwe.mitre.org/data/definitions/352.html"]}, "104": {"alertID": "20015", "alertName": "Heartbleed OpenSSL Vulnerability", "alertType": "Active", "alertRisk": "High", "alertCWEID": "119", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "The TLS implementation in OpenSSL 1.0.1 before 1.0.1g does not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, potentially disclosing sensitive information.", "alertSolution": "Update to OpenSSL 1.0.1g or later. Re-issue HTTPS certificates. Change asymmetric private keys and shared secret keys, since these may have been compromised, with no evidence of compromise in the server log files.", "alertOtherInfo": "This issue was confirmed by exfiltrating data from the server, using TLS 1.1. This is unlikely to be a false positive.", "alertReferences": ["https://nvd.nist.gov/vuln/detail/CVE-2014-0160"]}, "105": {"alertID": "20017", "alertName": "Source Code Disclosure - CVE-2012-1823", "alertType": "Active", "alertRisk": "High", "alertCWEID": "20", "alertWASCID": "20", "alertTechTargeted": "Language / PHP", "alertSummary": "Improper input handling is one of the most common weaknesses identified across applications today. Poorly handled input is a leading cause behind critical vulnerabilities that exist in systems and applications.", "alertSolution": "Phase: Architecture and Design  Use an input validation framework such as Struts or the OWASP ESAPI Validation API.  Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.  For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.  Do not rely exclusively on deny list validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.  When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.  Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  Phase: Implementation  Be especially careful to validate your input when you invoke code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.  Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.  Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.  When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/vulnerabilities/Improper_Data_Validation", "https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html", "https://cwe.mitre.org/data/definitions/89.html"]}, "106": {"alertID": "20018", "alertName": "Remote Code Execution - CVE-2012-1823", "alertType": "Active", "alertRisk": "High", "alertCWEID": "20", "alertWASCID": "20", "alertTechTargeted": "Language / PHP", "alertSummary": "Improper input handling is one of the most common weaknesses identified across applications today. Poorly handled input is a leading cause behind critical vulnerabilities that exist in systems and applications.", "alertSolution": "Phase: Architecture and Design  Use an input validation framework such as Struts or the OWASP ESAPI Validation API.  Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.  For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.  Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.  Do not rely exclusively on deny list validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.  When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.  Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  Phase: Implementation  Be especially careful to validate your input when you invoke code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.  Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.  Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.  Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.  When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/vulnerabilities/Improper_Data_Validation", "https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html", "https://cwe.mitre.org/data/definitions/89.html"]}, "107": {"alertID": "20019", "alertName": "External Redirect", "alertType": "Active", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "108": {"alertID": "20019-1", "alertName": "External Redirect", "alertType": "Active", "alertRisk": "High", "alertCWEID": "601", "alertWASCID": "38", "alertTechTargeted": "All", "alertSummary": "URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.", "alertSolution": "Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  Use an allow list of approved URLs or domains to be used for redirection.  Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.  When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  For example, ID 1 could map to \"/login.asp\" and ID 2 could map to \"https://www.example.com/\". Features such as the ESAPI AccessReferenceMap provide this capability.  Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.", "alertOtherInfo": "The response contains a redirect in its Location header which allows an external Url to be set.", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html", "https://cwe.mitre.org/data/definitions/601.html"]}, "109": {"alertID": "20019-2", "alertName": "External Redirect", "alertType": "Active", "alertRisk": "High", "alertCWEID": "601", "alertWASCID": "38", "alertTechTargeted": "All", "alertSummary": "URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.", "alertSolution": "Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  Use an allow list of approved URLs or domains to be used for redirection.  Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.  When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  For example, ID 1 could map to \"/login.asp\" and ID 2 could map to \"https://www.example.com/\". Features such as the ESAPI AccessReferenceMap provide this capability.  Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.", "alertOtherInfo": "The response contains a redirect in its Refresh header which allows an external Url to be set.", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html", "https://cwe.mitre.org/data/definitions/601.html"]}, "110": {"alertID": "20019-3", "alertName": "External Redirect", "alertType": "Active", "alertRisk": "High", "alertCWEID": "601", "alertWASCID": "38", "alertTechTargeted": "All", "alertSummary": "URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.", "alertSolution": "Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  Use an allow list of approved URLs or domains to be used for redirection.  Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.  When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  For example, ID 1 could map to \"/login.asp\" and ID 2 could map to \"https://www.example.com/\". Features such as the ESAPI AccessReferenceMap provide this capability.  Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.", "alertOtherInfo": "The response contains a redirect in its meta http-equiv tag for 'Refresh' which allows an external Url to be set.", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html", "https://cwe.mitre.org/data/definitions/601.html"]}, "111": {"alertID": "20019-4", "alertName": "External Redirect", "alertType": "Active", "alertRisk": "High", "alertCWEID": "601", "alertWASCID": "38", "alertTechTargeted": "All", "alertSummary": "URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.", "alertSolution": "Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  Use an allow list of approved URLs or domains to be used for redirection.  Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.  When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.  For example, ID 1 could map to \"/login.asp\" and ID 2 could map to \"https://www.example.com/\". Features such as the ESAPI AccessReferenceMap provide this capability.  Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.  Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.", "alertOtherInfo": "The response contains a redirect in its JavaScript code which allows an external Url to be set.", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html", "https://cwe.mitre.org/data/definitions/601.html"]}, "112": {"alertID": "30001", "alertName": "Buffer Overflow", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "120", "alertWASCID": "7", "alertTechTargeted": "Language / C", "alertSummary": "Buffer overflow errors are characterized by the overwriting of memory spaces of the background web process, which should have never been modified intentionally or unintentionally. Overwriting values of the IP (Instruction Pointer), BP (Base Pointer) and other registers causes exceptions, segmentation faults, and other process errors to occur. Usually these errors end execution of the application in an unexpected way.", "alertSolution": "Rewrite the background program using proper return length checking.  This will require a recompile of the background executable.", "alertOtherInfo": "Potential Buffer Overflow.  The script closed the connection and threw a 500 Internal Server Error", "alertReferences": ["https://owasp.org/www-community/attacks/Buffer_overflow_attack"]}, "113": {"alertID": "30002", "alertName": "Format String Error", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "134", "alertWASCID": "6", "alertTechTargeted": "Language / C", "alertSummary": "A Format String error occurs when the submitted data of an input string is evaluated as a command by the application.", "alertSolution": "Rewrite the background program using proper deletion of bad character strings.  This will require a recompile of the background executable.", "alertOtherInfo": "Potential Format String Error.  The script closed the connection on a /%s", "alertReferences": ["https://owasp.org/www-community/attacks/Format_string_attack"]}, "114": {"alertID": "40003", "alertName": "CRLF Injection", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "113", "alertWASCID": "25", "alertTechTargeted": "All", "alertSummary": "Cookie can be set via CRLF injection.  It may also be possible to set arbitrary HTTP response headers. In addition, by carefully crafting the injected response using cross-site script, cache poisoning vulnerability may also exist.", "alertSolution": "Type check the submitted parameter carefully. Do not allow CRLF to be injected by filtering CRLF.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/vulnerabilities/CRLF_Injection", "https://cwe.mitre.org/data/definitions/113.html"]}, "115": {"alertID": "40008", "alertName": "Parameter Tampering", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "472", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "Parameter manipulation caused an error page or Java stack trace to be displayed.  This indicated lack of exception handling and potential areas for further exploit.", "alertSolution": "Identify the cause of the error and fix it.  Do not trust client side input and enforce a tight check in the server side.  Besides, catch the exception properly.  Use a generic 500 error page for internal server error.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "116": {"alertID": "40009", "alertName": "Server Side Include", "alertType": "Active", "alertRisk": "High", "alertCWEID": "97", "alertWASCID": "31", "alertTechTargeted": "OS / Linux", "alertSummary": "Certain parameters may cause Server Side Include commands to be executed.  This may allow database connection or arbitrary code to be executed.", "alertSolution": "Do not trust client side input and enforce a tight check in the server side. Disable server side includes. Refer to manual to disable Sever Side Include. Use least privilege to run your web server or application server. For Apache, disable the following: Options Indexes FollowSymLinks Includes AddType application/x-httpd-cgi .cgi AddType text/x-server-parsed-html .html", "alertOtherInfo": "N/A", "alertReferences": ["https://httpd.apache.org/docs/current/howto/ssi.html"]}, "117": {"alertID": "40012", "alertName": "Cross Site Scripting (Reflected)", "alertType": "Active", "alertRisk": "High", "alertCWEID": "79", "alertWASCID": "8", "alertTechTargeted": "All", "alertSummary": "Cross-site Scripting (XSS) is an attack technique that involves echoing attacker-supplied code into a user\u2019s browser instance. A browser instance can be a standard web browser client, or a browser object embedded in a software product such as the browser within WinAmp, an RSS reader, or an email client. The code itself is usually written in HTML/JavaScript, but may also extend to VBScript, ActiveX, Java, Flash, or any other browser-supported technology.\nWhen an attacker gets a user\u2019s browser to execute his/her code, the code will run within the security context (or zone) of the hosting web site. With this level of privilege, the code has the ability to read, modify and transmit any sensitive data accessible by the browser. A Cross-site Scripted user could have his/her account hijacked (cookie theft), their browser redirected to another location, or possibly shown fraudulent content delivered by the web site they are visiting. Cross-site Scripting attacks essentially compromise the trust relationship between a user and the web site. Applications utilizing browser object instances which load content from the file system may execute code under the local machine zone allowing for system compromise.", "alertSolution": "Phase: Architecture and Design Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.  Phases: Implementation; Architecture and Design Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies. For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters. Consult the XSS Prevention Cheat Sheet for more details on the types of encoding and escaping that are needed.  Phase: Architecture and Design For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.  If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.  Phase: Implementation For every web page that is generated, use and specify a character encoding such as ISO-8859-1 or UTF-8. When an encoding is not specified, the web browser may choose a different encoding by guessing which encoding is actually being used by the web page. This can cause the web browser to treat certain sequences as special, opening up the client to subtle XSS attacks. See CWE-116 for more mitigations related to encoding/escaping.  To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.  Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/xss/", "https://cwe.mitre.org/data/definitions/79.html"]}, "118": {"alertID": "40014", "alertName": "Cross Site Scripting (Persistent)", "alertType": "Active", "alertRisk": "High", "alertCWEID": "79", "alertWASCID": "8", "alertTechTargeted": "All", "alertSummary": "Cross-site Scripting (XSS) is an attack technique that involves echoing attacker-supplied code into a user\u2019s browser instance. A browser instance can be a standard web browser client, or a browser object embedded in a software product such as the browser within WinAmp, an RSS reader, or an email client. The code itself is usually written in HTML/JavaScript, but may also extend to VBScript, ActiveX, Java, Flash, or any other browser-supported technology.\nWhen an attacker gets a user\u2019s browser to execute his/her code, the code will run within the security context (or zone) of the hosting web site. With this level of privilege, the code has the ability to read, modify and transmit any sensitive data accessible by the browser. A Cross-site Scripted user could have his/her account hijacked (cookie theft), their browser redirected to another location, or possibly shown fraudulent content delivered by the web site they are visiting. Cross-site Scripting attacks essentially compromise the trust relationship between a user and the web site. Applications utilizing browser object instances which load content from the file system may execute code under the local machine zone allowing for system compromise.", "alertSolution": "Phase: Architecture and Design Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.  Phases: Implementation; Architecture and Design Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies. For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters. Consult the XSS Prevention Cheat Sheet for more details on the types of encoding and escaping that are needed.  Phase: Architecture and Design For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.  If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.  Phase: Implementation For every web page that is generated, use and specify a character encoding such as ISO-8859-1 or UTF-8. When an encoding is not specified, the web browser may choose a different encoding by guessing which encoding is actually being used by the web page. This can cause the web browser to treat certain sequences as special, opening up the client to subtle XSS attacks. See CWE-116 for more mitigations related to encoding/escaping.  To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.  Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/xss/", "https://cwe.mitre.org/data/definitions/79.html"]}, "119": {"alertID": "40016", "alertName": "Cross Site Scripting (Persistent) - Prime", "alertType": "Active", "alertRisk": "Informational", "alertCWEID": "79", "alertWASCID": "8", "alertTechTargeted": "All"}, "120": {"alertID": "40017", "alertName": "Cross Site Scripting (Persistent) - Spider", "alertType": "Active", "alertRisk": "Informational", "alertCWEID": "79", "alertWASCID": "8", "alertTechTargeted": "All"}, "121": {"alertID": "40018", "alertName": "SQL Injection", "alertType": "Active", "alertRisk": "High", "alertCWEID": "89", "alertWASCID": "19", "alertTechTargeted": "Db / Firebird", "alertSummary": "SQL injection may be possible.", "alertSolution": "Do not trust client side input, even if there is client side validation in place. In general, type check all data on the server side. If the application uses JDBC, use PreparedStatement or CallableStatement, with parameters passed by '?' If the application uses ASP, use ADO Command Objects with strong type checking and parameterized queries. If database Stored Procedures can be used, use them. Do *not* concatenate strings into queries in the stored procedure, or use 'exec', 'exec immediate', or equivalent functionality! Do not create dynamic SQL queries using simple string concatenation. Escape all data received from the client. Apply an 'allow list' of allowed characters, or a 'deny list' of disallowed characters in user input. Apply the principle of least privilege by using the least privileged database user possible. In particular, avoid using the 'sa' or 'db-owner' database users. This does not eliminate SQL injection, but minimizes its impact. Grant the minimum database access that is necessary for the application.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"]}, "122": {"alertID": "40019", "alertName": "SQL Injection - MySQL", "alertType": "Active", "alertRisk": "High", "alertCWEID": "89", "alertWASCID": "19", "alertTechTargeted": "Db / MySQL", "alertSummary": "SQL injection may be possible.", "alertSolution": "Do not trust client side input, even if there is client side validation in place. In general, type check all data on the server side. If the application uses JDBC, use PreparedStatement or CallableStatement, with parameters passed by '?' If the application uses ASP, use ADO Command Objects with strong type checking and parameterized queries. If database Stored Procedures can be used, use them. Do *not* concatenate strings into queries in the stored procedure, or use 'exec', 'exec immediate', or equivalent functionality! Do not create dynamic SQL queries using simple string concatenation. Escape all data received from the client. Apply an 'allow list' of allowed characters, or a 'deny list' of disallowed characters in user input. Apply the principle of least privilege by using the least privileged database user possible. In particular, avoid using the 'sa' or 'db-owner' database users. This does not eliminate SQL injection, but minimizes its impact. Grant the minimum database access that is necessary for the application.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"]}, "123": {"alertID": "40020", "alertName": "SQL Injection - Hypersonic SQL", "alertType": "Active", "alertRisk": "High", "alertCWEID": "89", "alertWASCID": "19", "alertTechTargeted": "Db / HypersonicSQL", "alertSummary": "SQL injection may be possible.", "alertSolution": "Do not trust client side input, even if there is client side validation in place. In general, type check all data on the server side. If the application uses JDBC, use PreparedStatement or CallableStatement, with parameters passed by '?' If the application uses ASP, use ADO Command Objects with strong type checking and parameterized queries. If database Stored Procedures can be used, use them. Do *not* concatenate strings into queries in the stored procedure, or use 'exec', 'exec immediate', or equivalent functionality! Do not create dynamic SQL queries using simple string concatenation. Escape all data received from the client. Apply an 'allow list' of allowed characters, or a 'deny list' of disallowed characters in user input. Apply the principle of least privilege by using the least privileged database user possible. In particular, avoid using the 'sa' or 'db-owner' database users. This does not eliminate SQL injection, but minimizes its impact. Grant the minimum database access that is necessary for the application.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"]}, "124": {"alertID": "40021", "alertName": "SQL Injection - Oracle", "alertType": "Active", "alertRisk": "High", "alertCWEID": "89", "alertWASCID": "19", "alertTechTargeted": "Db / Oracle", "alertSummary": "SQL injection may be possible.", "alertSolution": "Do not trust client side input, even if there is client side validation in place. In general, type check all data on the server side. If the application uses JDBC, use PreparedStatement or CallableStatement, with parameters passed by '?' If the application uses ASP, use ADO Command Objects with strong type checking and parameterized queries. If database Stored Procedures can be used, use them. Do *not* concatenate strings into queries in the stored procedure, or use 'exec', 'exec immediate', or equivalent functionality! Do not create dynamic SQL queries using simple string concatenation. Escape all data received from the client. Apply an 'allow list' of allowed characters, or a 'deny list' of disallowed characters in user input. Apply the principle of least privilege by using the least privileged database user possible. In particular, avoid using the 'sa' or 'db-owner' database users. This does not eliminate SQL injection, but minimizes its impact. Grant the minimum database access that is necessary for the application.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"]}, "125": {"alertID": "40022", "alertName": "SQL Injection - PostgreSQL", "alertType": "Active", "alertRisk": "High", "alertCWEID": "89", "alertWASCID": "19", "alertTechTargeted": "Db / PostgreSQL", "alertSummary": "SQL injection may be possible.", "alertSolution": "Do not trust client side input, even if there is client side validation in place. In general, type check all data on the server side. If the application uses JDBC, use PreparedStatement or CallableStatement, with parameters passed by '?' If the application uses ASP, use ADO Command Objects with strong type checking and parameterized queries. If database Stored Procedures can be used, use them. Do *not* concatenate strings into queries in the stored procedure, or use 'exec', 'exec immediate', or equivalent functionality! Do not create dynamic SQL queries using simple string concatenation. Escape all data received from the client. Apply an 'allow list' of allowed characters, or a 'deny list' of disallowed characters in user input. Apply the principle of least privilege by using the least privileged database user possible. In particular, avoid using the 'sa' or 'db-owner' database users. This does not eliminate SQL injection, but minimizes its impact. Grant the minimum database access that is necessary for the application.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"]}, "126": {"alertID": "40024", "alertName": "SQL Injection - SQLite", "alertType": "Active", "alertRisk": "High", "alertCWEID": "89", "alertWASCID": "19", "alertTechTargeted": "Db / SQLite", "alertSummary": "SQL injection may be possible.", "alertSolution": "Do not trust client side input, even if there is client side validation in place. In general, type check all data on the server side. If the application uses JDBC, use PreparedStatement or CallableStatement, with parameters passed by '?' If the application uses ASP, use ADO Command Objects with strong type checking and parameterized queries. If database Stored Procedures can be used, use them. Do *not* concatenate strings into queries in the stored procedure, or use 'exec', 'exec immediate', or equivalent functionality! Do not create dynamic SQL queries using simple string concatenation. Escape all data received from the client. Apply an 'allow list' of allowed characters, or a 'deny list' of disallowed characters in user input. Apply the principle of least privilege by using the least privileged database user possible. In particular, avoid using the 'sa' or 'db-owner' database users. This does not eliminate SQL injection, but minimizes its impact. Grant the minimum database access that is necessary for the application.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"]}, "127": {"alertID": "40026", "alertName": "Cross Site Scripting (DOM Based)", "alertType": "Active", "alertRisk": "High", "alertCWEID": "79", "alertWASCID": "8", "alertTechTargeted": "All", "alertSummary": "Cross-site Scripting (XSS) is an attack technique that involves echoing attacker-supplied code into a user\u2019s browser instance. A browser instance can be a standard web browser client, or a browser object embedded in a software product such as the browser within WinAmp, an RSS reader, or an email client. The code itself is usually written in HTML/JavaScript, but may also extend to VBScript, ActiveX, Java, Flash, or any other browser-supported technology.\nWhen an attacker gets a user\u2019s browser to execute his/her code, the code will run within the security context (or zone) of the hosting web site. With this level of privilege, the code has the ability to read, modify and transmit any sensitive data accessible by the browser. A Cross-site Scripted user could have his/her account hijacked (cookie theft), their browser redirected to another location, or possibly shown fraudulent content delivered by the web site they are visiting. Cross-site Scripting attacks essentially compromise the trust relationship between a user and the web site. Applications utilizing browser object instances which load content from the file system may execute code under the local machine zone allowing for system compromise.", "alertSolution": "Phase: Architecture and Design Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.  Phases: Implementation; Architecture and Design Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies. For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters. Consult the XSS Prevention Cheat Sheet for more details on the types of encoding and escaping that are needed.  Phase: Architecture and Design For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.  If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.  Phase: Implementation For every web page that is generated, use and specify a character encoding such as ISO-8859-1 or UTF-8. When an encoding is not specified, the web browser may choose a different encoding by guessing which encoding is actually being used by the web page. This can cause the web browser to treat certain sequences as special, opening up the client to subtle XSS attacks. See CWE-116 for more mitigations related to encoding/escaping.  To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.  Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/xss/", "https://cwe.mitre.org/data/definitions/79.html"]}, "128": {"alertID": "40027", "alertName": "SQL Injection - MsSQL", "alertType": "Active", "alertRisk": "High", "alertCWEID": "89", "alertWASCID": "19", "alertTechTargeted": "Db / Microsoft SQL Server", "alertSummary": "SQL injection may be possible.", "alertSolution": "Do not trust client side input, even if there is client side validation in place. In general, type check all data on the server side. If the application uses JDBC, use PreparedStatement or CallableStatement, with parameters passed by '?' If the application uses ASP, use ADO Command Objects with strong type checking and parameterized queries. If database Stored Procedures can be used, use them. Do *not* concatenate strings into queries in the stored procedure, or use 'exec', 'exec immediate', or equivalent functionality! Do not create dynamic SQL queries using simple string concatenation. Escape all data received from the client. Apply an 'allow list' of allowed characters, or a 'deny list' of disallowed characters in user input. Apply the principle of least privilege by using the least privileged database user possible. In particular, avoid using the 'sa' or 'db-owner' database users. This does not eliminate SQL injection, but minimizes its impact. Grant the minimum database access that is necessary for the application.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"]}, "129": {"alertID": "40028", "alertName": "ELMAH Information Leak", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "94", "alertWASCID": "14", "alertTechTargeted": "Db / Microsoft SQL Server", "alertSummary": "The Error Logging Modules and Handlers (ELMAH [elmah.axd]) HTTP Module was found to be available. This module can leak a significant amount of valuable information.", "alertSolution": "Consider whether or not ELMAH is actually required in production, if it isn't then disable it. If it is then ensure access to it requires authentication and authorization. See also: https://elmah.github.io/a/securing-error-log-pages/", "alertOtherInfo": "N/A", "alertReferences": ["https://www.troyhunt.com/aspnet-session-hijacking-with-google/", "https://www.nuget.org/packages/elmah", "https://elmah.github.io/"]}, "130": {"alertID": "40029", "alertName": "Trace.axd Information Leak", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "215", "alertWASCID": "13", "alertTechTargeted": "Db / Microsoft SQL Server", "alertSummary": "The ASP.NET Trace Viewer (trace.axd) was found to be available. This component can leak a significant amount of valuable information.", "alertSolution": "Consider whether or not Trace Viewer is actually required in production, if it isn't then disable it. If it is then ensure access to it requires authentication and authorization.", "alertOtherInfo": "N/A", "alertReferences": ["https://msdn.microsoft.com/en-us/library/bb386420.aspx", "https://msdn.microsoft.com/en-us/library/wwh16c6c.aspx", "https://www.dotnetperls.com/trace"]}, "131": {"alertID": "40032", "alertName": ".htaccess Information Leak", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "94", "alertWASCID": "14", "alertTechTargeted": "WS / Apache", "alertSummary": "htaccess files can be used to alter the configuration of the Apache Web Server software to enable/disable additional functionality and features that the Apache Web Server software has to offer.", "alertSolution": "Ensure the .htaccess file is not accessible.", "alertOtherInfo": "N/A", "alertReferences": ["https://developer.mozilla.org/en-US/docs/Learn/Server-side/Apache_Configuration_htaccess", "https://httpd.apache.org/docs/2.4/howto/htaccess.html"]}, "132": {"alertID": "40034", "alertName": ".env Information Leak", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "215", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "One or more .env files seems to have been located on the server. These files often expose infrastructure or administrative account credentials, API or APP keys, or other sensitive configuration information.", "alertSolution": "Ensure the .env file is not accessible.", "alertOtherInfo": "N/A", "alertReferences": ["https://www.google.com/search?q=db_password+filetype%3Aenv", "https://mobile.twitter.com/svblxyz/status/1045013939904532482"]}, "133": {"alertID": "40035", "alertName": "Hidden File Found", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "538", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "A sensitive file was identified as accessible or available. This may leak administrative, configuration, or credential information which can be leveraged by a malicious individual to further attack the system or conduct social engineering efforts.", "alertSolution": "Consider whether or not the component is actually required in production, if it isn't then disable it. If it is then ensure access to it requires appropriate authentication and authorization, or limit exposure to internal systems or specific source IPs, etc.", "alertOtherInfo": "cvs_dir", "alertReferences": ["https://blog.hboeck.de/archives/892-Introducing-Snallygaster-a-Tool-to-Scan-for-Secrets-on-Web-Servers.html"]}, "134": {"alertID": "40042", "alertName": "Spring Actuator Information Leak", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "215", "alertWASCID": "13", "alertTechTargeted": "Language / Java", "alertSummary": "Spring Actuator for Health is enabled and may reveal sensitive information about this application. Spring Actuators can be used for real monitoring purposes, but should be used with caution as to not expose too much information about the application or the infrastructure running it.", "alertSolution": "Disable the Health Actuators and other actuators, or restrict them to administrative users.", "alertOtherInfo": "N/A", "alertReferences": ["https://docs.spring.io/spring-boot/docs/current/actuator-api/htmlsingle/#overview"]}, "135": {"alertID": "40043", "alertName": "Log4Shell", "alertType": "Active", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "136": {"alertID": "40043-1", "alertName": "Log4Shell (CVE-2021-44228)", "alertType": "Active", "alertRisk": "High", "alertCWEID": "117", "alertWASCID": "20", "alertTechTargeted": "Language / Java", "alertSummary": "Apache Log4j2 <=2.14.1 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled. From log4j 2.15.0, this behavior has been disabled by default.", "alertSolution": "Upgrade Log4j2 to version 2.17.1 or newer. In previous releases (>2.10) this behavior can be mitigated by setting system property \"log4j2.formatMsgNoLookups\" to \"true\" or by removing the JndiLookup class from the classpath (example: zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class). Java 8u121 (see https://www.oracle.com/java/technologies/javase/8u121-relnotes.html) protects against remote code execution by defaulting \"com.sun.jndi.rmi.object.trustURLCodebase\" and \"com.sun.jndi.cosnaming.object.trustURLCodebase\" to \"false\".", "alertOtherInfo": "N/A", "alertReferences": ["https://www.lunasec.io/docs/blog/log4j-zero-day/", "https://nvd.nist.gov/vuln/detail/CVE-2021-44228"]}, "137": {"alertID": "40043-2", "alertName": "Log4Shell (CVE-2021-45046)", "alertType": "Active", "alertRisk": "High", "alertCWEID": "117", "alertWASCID": "20", "alertTechTargeted": "Language / Java", "alertSummary": "It was found that the fix to address CVE-2021-44228 in Apache Log4j 2.15.0 was incomplete in certain non-default configurations. This could allow attackers to craft malicious input data using a JNDI Lookup pattern resulting in an information leak and remote code execution in some environments.", "alertSolution": "Upgrade Log4j2 to version 2.17.1 or newer.", "alertOtherInfo": "N/A", "alertReferences": ["https://www.lunasec.io/docs/blog/log4j-zero-day/", "https://nvd.nist.gov/vuln/detail/CVE-2021-45046"]}, "138": {"alertID": "40045", "alertName": "Spring4Shell", "alertType": "Active", "alertRisk": "High", "alertCWEID": "78", "alertWASCID": "20", "alertTechTargeted": "Language / Java", "alertSummary": "The application appears to be vulnerable to CVE-2022-22965 (otherwise known as Spring4Shell) - remote code execution (RCE) via data binding.", "alertSolution": "Upgrade Spring Framework to versions 5.3.18, 5.2.20, or newer.", "alertOtherInfo": "N/A", "alertReferences": ["https://nvd.nist.gov/vuln/detail/CVE-2022-22965", "https://www.rapid7.com/blog/post/2022/03/30/spring4shell-zero-day-vulnerability-in-spring-framework/", "https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement#vulnerability", "https://tanzu.vmware.com/security/cve-2022-22965"]}, "139": {"alertID": "90001", "alertName": "Insecure JSF ViewState", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "642", "alertWASCID": "14", "alertTechTargeted": "All", "alertSummary": "The response at the following URL contains a ViewState value that has no cryptographic protections.", "alertSolution": "Secure VIEWSTATE with a MAC specific to your environment", "alertOtherInfo": "N/A", "alertReferences": ["https://www.trustwave.com/spiderlabs/advisories/TWSL2010-001.txt"]}, "140": {"alertID": "90011", "alertName": "Charset Mismatch", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "436", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "This check identifies responses where the HTTP Content-Type header declares a charset different from the charset defined by the body of the HTML or XML. When there\u2019s a charset mismatch between the HTTP header and content body Web browsers can be forced into an undesirable content-sniffing mode to determine the content\u2019s correct character set.", "alertSolution": "Force UTF-8 for all text content in both the HTTP header and meta tags in HTML or encoding declarations in XML.", "alertOtherInfo": "N/A", "alertReferences": ["https://code.google.com/p/browsersec/wiki/Part2#Character_set_handling_and_detection"]}, "141": {"alertID": "90017", "alertName": "XSLT Injection", "alertType": "Active", "alertRisk": "Medium", "alertCWEID": "91", "alertWASCID": "23", "alertTechTargeted": "All", "alertSummary": "Injection using XSL transformations may be possible, and may allow an attacker to read system information, read and write files, or execute arbitrary code.", "alertSolution": "Sanitize and analyze every user input coming from any client-side.", "alertOtherInfo": "N/A", "alertReferences": ["https://www.contextis.com/blog/xslt-server-side-injection-attacks"]}, "142": {"alertID": "90019", "alertName": "Server Side Code Injection", "alertType": "Active", "alertRisk": "N/A", "alertCWEID": "N/A", "alertWASCID": "N/A", "alertTechTargeted": "N/A", "alertSummary": "See child errors.", "alertSolution": "N/A", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "143": {"alertID": "90019-1", "alertName": "Server Side Code Injection - PHP Code Injection", "alertType": "Active", "alertRisk": "High", "alertCWEID": "94", "alertWASCID": "20", "alertTechTargeted": "Language / ASP", "alertSummary": "A code injection may be possible including custom code that will be evaluated by the scripting engine", "alertSolution": "Do not trust client side input, even if there is client side validation in place. In general, type check all data on the server side and escape all data received from the client.  Avoid the use of eval() functions combined with user input data.", "alertOtherInfo": "N/A", "alertReferences": ["https://cwe.mitre.org/data/definitions/94.html", "https://owasp.org/www-community/attacks/Direct_Dynamic_Code_Evaluation_Eval%20Injection"]}, "144": {"alertID": "90019-2", "alertName": "Server Side Code Injection - ASP Code Injection", "alertType": "Active", "alertRisk": "High", "alertCWEID": "94", "alertWASCID": "20", "alertTechTargeted": "Language / ASP", "alertSummary": "A code injection may be possible including custom code that will be evaluated by the scripting engine", "alertSolution": "Do not trust client side input, even if there is client side validation in place. In general, type check all data on the server side and escape all data received from the client.  Avoid the use of eval() functions combined with user input data.", "alertOtherInfo": "N/A", "alertReferences": ["https://cwe.mitre.org/data/definitions/94.html", "https://owasp.org/www-community/attacks/Direct_Dynamic_Code_Evaluation_Eval%20Injection"]}, "145": {"alertID": "90020", "alertName": "Remote OS Command Injection", "alertType": "Active", "alertRisk": "High", "alertCWEID": "78", "alertWASCID": "31", "alertTechTargeted": "OS / Linux", "alertSummary": "Attack technique used for unauthorized execution of operating system commands. This attack is possible when an application accepts untrusted input to build operating system commands in an insecure manner involving improper data sanitization, and/or improper calling of external programs.", "alertSolution": "If at all possible, use library calls rather than external processes to recreate the desired functionality.  Run your code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by your software.  OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows you to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise.  For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the command locally in the session's state instead of sending it out to the client in a hidden form field.  Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.  For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.  If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allow list (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection.  If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.  If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.  Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.  Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use an allow list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a deny list). However, deny lists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.  When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as \"red\" or \"blue.\"  When constructing OS command strings, use stringent allow lists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.  Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like \";\" and \">\" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.  Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.", "alertOtherInfo": "The scan rule was able to retrieve the content of a file or command by sending [a;cat /etc/passwd ] to the operating system running this application", "alertReferences": ["https://cwe.mitre.org/data/definitions/78.html", "https://owasp.org/www-community/attacks/Command_Injection"]}, "146": {"alertID": "90021", "alertName": "XPath Injection", "alertType": "Active", "alertRisk": "High", "alertCWEID": "643", "alertWASCID": "39", "alertTechTargeted": "All", "alertSummary": "XPath Injection is an attack technique used to exploit applications that construct XPath (XML Path Language) queries from user-supplied input to query or navigate XML documents. It can be used directly by an application to query an XML document, as part of a larger operation such as applying an XSLT transformation to an XML document, or applying an XQuery to an XML document. The syntax of XPath bears some resemblance to an SQL query, and indeed, it is possible to form SQL-like queries on an XML document using XPath.", "alertSolution": "Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane.  Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/attacks/XPATH_Injection", "https://owasp.org/www-community/attacks/Blind_XPath_Injection", "https://cwe.mitre.org/data/definitions/643.html"]}, "147": {"alertID": "90022", "alertName": "Application Error Disclosure", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "This page contains an error/warning message that may disclose sensitive information like the location of the file that produced the unhandled exception. This information can be used to launch further attacks against the web application. The alert could be a false positive if the error message is found inside a documentation page.", "alertSolution": "Review the source code of this page. Implement custom error pages. Consider implementing a mechanism to provide a unique error reference/identifier to the client (browser) while logging the details on the server side and not exposing them to the user.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "148": {"alertID": "90023", "alertName": "XML External Entity Attack", "alertType": "Active", "alertRisk": "High", "alertCWEID": "611", "alertWASCID": "43", "alertTechTargeted": "All", "alertSummary": "This technique takes advantage of a feature of XML to build documents dynamically at the time of processing. An XML message can either provide data explicitly or by pointing to an URI where the data exists. In the attack technique, external entities may replace the entity value with malicious data, alternate referrals or may compromise the security of the data the server/XML application has access to.\nAttackers may also use External Entities to have the web services server download malicious code or content to the server for use in secondary or follow on attacks.", "alertSolution": "XML External Entities vulnerabilities arise because the application's XML parsing library supports potentially dangerous XML features. To prevent XML External Entities vulnerabilities disable the resolution of external entities and the support for XInclude.", "alertOtherInfo": "N/A", "alertReferences": ["https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing", "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html", "https://cwe.mitre.org/data/definitions/611.html"]}, "149": {"alertID": "90024", "alertName": "Generic Padding Oracle", "alertType": "Active", "alertRisk": "High", "alertCWEID": "209", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "By manipulating the padding on an encrypted string, an attacker is able to generate an error message that indicates a likely \u2018padding oracle\u2019 vulnerability. Such a vulnerability can affect any application or framework that uses encryption improperly, such as some versions of ASP.net, Java Server Faces, and Mono. An attacker may exploit this issue to decrypt data and recover encryption keys, potentially viewing and modifying confidential data. This rule should detect the MS10-070 padding oracle vulnerability in ASP.net if CustomErrors are enabled for that.", "alertSolution": "Update the affected server software, or modify the scripts so that they properly validate encrypted data before attempting decryption.", "alertOtherInfo": "N/A", "alertReferences": ["https://learn.microsoft.com/en-us/security-updates/securitybulletins/2010/ms10-070", "https://www.mono-project.com/docs/about-mono/vulnerabilities/", "https://bugzilla.redhat.com/show_bug.cgi?id=623799"]}, "150": {"alertID": "90033", "alertName": "Loosely Scoped Cookie", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "565", "alertWASCID": "15", "alertTechTargeted": "All", "alertSummary": "Cookies can be scoped by domain or path. This check is only concerned with domain scope.The domain scope applied to a cookie determines which domains can access it. For example, a cookie can be scoped strictly to a subdomain e.g. www.nottrusted.com, or loosely scoped to a parent domain e.g. nottrusted.com. In the latter case, any subdomain of nottrusted.com can access the cookie. Loosely scoped cookies are common in mega-applications like google.com and live.com. Cookies set from a subdomain like app.foo.bar are transmitted only to that domain by the browser. However, cookies scoped to a parent-level domain may be transmitted to the parent, or any subdomain of the parent.", "alertSolution": "Always scope cookies to a FQDN (Fully Qualified Domain Name).", "alertOtherInfo": "The origin domain used for comparison was:  subdomain.example.com name=value", "alertReferences": ["https://tools.ietf.org/html/rfc6265#section-4.1", "https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/02-Testing_for_Cookies_Attributes.html", "https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_cookies"]}, "151": {"alertID": "90034", "alertName": "Cloud Metadata Potentially Exposed", "alertType": "Active", "alertRisk": "High", "alertCWEID": "WASC", "alertWASCID": "All", "alertTechTargeted": "OWASP_2017_A06", "alertSummary": "The Cloud Metadata Attack attempts to abuse a misconfigured NGINX server in order to access the instance metadata maintained by cloud service providers such as AWS, GCP and Azure.\nAll of these providers provide metadata via an internal unroutable IP address \u2018169.254.169.254\u2019 - this can be exposed by incorrectly configured NGINX servers and accessed by using this IP address in the Host header field.", "alertSolution": "Do not trust any user data in NGINX configs. In this case it is probably the use of the $host variable which is set from the 'Host' header and can be controlled by an attacker.", "alertOtherInfo": "Based on the successful response status code cloud metadata may have been returned in the response. Check the response data to see if any cloud metadata has been returned. The meta data returned can include information that would allow an attacker to completely compromise the system.", "alertReferences": ["https://www.nginx.com/blog/trust-no-one-perils-of-trusting-user-input/"]}, "152": {"alertID": "90035", "alertName": "Server Side Template Injection", "alertType": "Active", "alertRisk": "High", "alertCWEID": "94", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "When the user input is inserted in the template instead of being used as argument in rendering is evaluated by the template engine. Depending on the template engine it can lead to remote code execution.", "alertSolution": "Instead of inserting the user input in the template, use it as rendering argument.", "alertOtherInfo": "N/A", "alertReferences": ["https://portswigger.net/blog/server-side-template-injection"]}, "153": {"alertID": "90036", "alertName": "Server Side Template Injection (Blind)", "alertType": "Active", "alertRisk": "High", "alertCWEID": "74", "alertWASCID": "20", "alertTechTargeted": "All", "alertSummary": "When the user input is inserted in the template instead of being used as argument in rendering is evaluated by the template engine. Depending on the template engine it can lead to remote code execution.", "alertSolution": "Instead of inserting the user input in the template, use it as rendering argument.", "alertOtherInfo": "N/A", "alertReferences": ["https://portswigger.net/blog/server-side-template-injection"]}, "154": {"alertID": "110001", "alertName": "Application Error Disclosure via WebSockets", "alertType": "Passive", "alertRisk": "Medium", "alertCWEID": "209", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "This payload contains an error/warning message that may disclose sensitive information like the location of the file that produced the unhandled exception. This information can be used to launch further attacks against the web application.", "alertSolution": "Review the error payloads which are piped directly to WebSockets. Handle the related exceptions. Consider implementing a mechanism to provide a unique error reference/identifier to the client (browser) while logging the details on the server side and not exposing them to the user.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "155": {"alertID": "110002", "alertName": "Base64 Disclosure in WebSocket message", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "WASC", "alertWASCID": "All"}, "156": {"alertID": "110003", "alertName": "Information Disclosure - Debug Error Messages via WebSocket", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The response appeared to contain common error messages returned by platforms such as ASP.NET, and Web-servers such as IIS and Apache. You can configure the list of common debug messages.", "alertSolution": "Disable debugging messages before pushing to production.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "157": {"alertID": "110004", "alertName": "Email address found in WebSocket message", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "An email address was found in a WebSocket Message.", "alertSolution": "Remove emails that are not public.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "158": {"alertID": "110005", "alertName": "Personally Identifiable Information via WebSocket", "alertType": "Passive", "alertRisk": "High", "alertCWEID": "359", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The response contains Personally Identifiable Information, such as CC number. Credit Card type detected: undefined.", "alertSolution": "Solution", "alertOtherInfo": "N/A", "alertReferences": "N/A"}, "159": {"alertID": "110006", "alertName": "Private IP Disclosure via WebSocket", "alertType": "Passive", "alertRisk": "Low", "alertCWEID": "WASC", "alertWASCID": "All"}, "160": {"alertID": "110007", "alertName": "Username Hash Found in WebSocket message", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "284", "alertWASCID": "2", "alertTechTargeted": "All", "alertSummary": "A Example hash of {Example / context: Example} was found in incoming WebSocket message. This may indicate that the application is subject to an Insecure Direct Object Reference (IDOR) vulnerability. Manual testing will be required to see if this discovery can be abused.", "alertSolution": "Use per user or session indirect object references (create a temporary mapping at time of use). Or, ensure that each use of a direct object reference is tied to an authorization check to ensure the user is authorized for the requested object.", "alertOtherInfo": "N/A", "alertReferences": ["https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html", "https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References"]}, "161": {"alertID": "110008", "alertName": "Information Disclosure - Suspicious Comments in XML via WebSocket", "alertType": "Passive", "alertRisk": "Informational", "alertCWEID": "200", "alertWASCID": "13", "alertTechTargeted": "All", "alertSummary": "The response appears to contain suspicious comments which may help an attacker.", "alertSolution": "Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.", "alertOtherInfo": "N/A", "alertReferences": "N/A"}}